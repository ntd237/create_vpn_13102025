"""
Module x·ª≠ l√Ω logic VPN c·ªët l√µi.
ƒê·ªôc l·∫≠p v·ªõi CLI interface, c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng.
"""

import os
import json
import subprocess
import time
import requests
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)


# === C·∫§U H√åNH ===
PROTONVPN_API = "https://api.protonvpn.ch/vpn/logicals"
FREEVPN_API = "https://www.vpngate.net/api/iphone/"  # Backup: VPN Gate (public free VPN)
CONFIG_EXTENSION = ".ovpn"


class VPNCore:
    """Class qu·∫£n l√Ω k·∫øt n·ªëi VPN."""
    
    def __init__(self, config_dir: str = "vpn_configs"):
        """
        Kh·ªüi t·∫°o VPN Core.
        
        Args:
            config_dir: Th∆∞ m·ª•c l∆∞u config files
        """
        self.config_dir = config_dir
        self.current_process = None
        self.pid_file = os.path.join(config_dir, 'vpn.pid')
        self._ensure_config_dir()
    
    def _ensure_config_dir(self):
        """T·∫°o th∆∞ m·ª•c config n·∫øu ch∆∞a c√≥."""
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
            logger.info(f"ƒê√£ t·∫°o th∆∞ m·ª•c config: {self.config_dir}")
    
    def fetch_vpngate_servers(self) -> List[Dict]:
        """
        L·∫•y danh s√°ch VPN servers mi·ªÖn ph√≠ t·ª´ VPN Gate.
        VPN Gate l√† d·ªãch v·ª• ho√†n to√†n mi·ªÖn ph√≠, kh√¥ng c·∫ßn ƒëƒÉng k√Ω.
        
        Returns:
            List c√°c server info d·∫°ng dict
            
        Raises:
            Exception: N·∫øu kh√¥ng th·ªÉ fetch ƒë∆∞·ª£c servers
        """
        try:
            logger.info("ƒêang t·∫£i danh s√°ch servers t·ª´ VPN Gate...")
            # Bypass proxy ƒë·ªÉ tr√°nh l·ªói connection
            response = requests.get(FREEVPN_API, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()
            
            # Parse CSV response (skip header)
            lines = response.text.strip().split('\n')
            servers = []
            
            # Skip first 2 lines (headers) and last line (*END)
            for line in lines[2:-1]:
                parts = line.split(',')
                if len(parts) >= 15:
                    servers.append({
                        'hostname': parts[0],
                        'ip': parts[1],
                        'country': parts[5],
                        'country_code': parts[6],
                        'speed': int(parts[4]) if parts[4].isdigit() else 0,
                        'uptime': int(parts[10]) if parts[10].isdigit() else 0,
                        'score': int(parts[2]) if parts[2].isdigit() else 0,
                        'config_data': parts[14]  # Base64 encoded .ovpn
                    })
            
            # S·∫Øp x·∫øp theo t·ªëc ƒë·ªô v√† uptime
            servers.sort(key=lambda x: (x['speed'], x['uptime']), reverse=True)
            
            logger.info(f"‚úÖ T√¨m th·∫•y {len(servers)} servers kh·∫£ d·ª•ng")
            return servers
            
        except Exception as e:
            logger.error(f"L·ªói khi fetch servers: {e}")
            raise
    
    def list_countries(self) -> Dict[str, List[Dict]]:
        """
        L·∫•y danh s√°ch qu·ªëc gia c√≥ VPN servers.
        
        Returns:
            Dict v·ªõi key l√† country code, value l√† list servers
        """
        servers = self.fetch_vpngate_servers()
        
        countries = {}
        for server in servers:
            country = server['country_code']
            if country not in countries:
                countries[country] = []
            countries[country].append(server)
        
        return countries
    
    def download_config(self, country_code: str) -> Optional[str]:
        """
        T·∫£i config file cho qu·ªëc gia ch·ªâ ƒë·ªãnh.
        Ch·ªçn server t·ªët nh·∫•t (nhanh nh·∫•t, uptime cao).
        
        Args:
            country_code: M√£ qu·ªëc gia (VD: US, JP, UK)
            
        Returns:
            ƒê∆∞·ªùng d·∫´n file config ƒë√£ t·∫£i, ho·∫∑c None n·∫øu th·∫•t b·∫°i
        """
        try:
            countries = self.list_countries()
            country_code = country_code.upper()
            
            if country_code not in countries:
                logger.error(f"Kh√¥ng t√¨m th·∫•y servers cho qu·ªëc gia: {country_code}")
                available = ', '.join(sorted(countries.keys()))
                logger.info(f"C√°c qu·ªëc gia kh·∫£ d·ª•ng: {available}")
                return None
            
            # Ch·ªçn server t·ªët nh·∫•t
            server = countries[country_code][0]
            logger.info(f"Ch·ªçn server: {server['hostname']} ({server['country']})")
            logger.info(f"Speed: {server['speed']/1000000:.1f} Mbps, Uptime: {server['uptime']} ms")
            
            # Decode config data (base64)
            import base64
            config_data = base64.b64decode(server['config_data']).decode('utf-8')
            
            # L∆∞u file config
            config_filename = f"{country_code}_{server['hostname']}{CONFIG_EXTENSION}"
            config_path = os.path.join(self.config_dir, config_filename)
            
            with open(config_path, 'w', encoding='utf-8') as f:
                f.write(config_data)
            
            logger.info(f"‚úÖ ƒê√£ t·∫£i config: {config_path}")
            return config_path
            
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i config: {e}")
            return None
    
    def connect(self, config_path: str, require_admin: bool = False) -> bool:
        """
        K·∫øt n·ªëi VPN s·ª≠ d·ª•ng config file.
        
        Args:
            config_path: ƒê∆∞·ªùng d·∫´n file .ovpn
            require_admin: C√≥ y√™u c·∫ßu quy·ªÅn admin kh√¥ng
            
        Returns:
            True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        if not os.path.exists(config_path):
            logger.error(f"File config kh√¥ng t·ªìn t·∫°i: {config_path}")
            return False
        
        try:
            # Ki·ªÉm tra OpenVPN c√≥ ƒë∆∞·ª£c c√†i ƒë·∫∑t
            openvpn_cmd = self._find_openvpn()
            if not openvpn_cmd:
                logger.error("‚ùå OpenVPN ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t!")
                logger.info("Vui l√≤ng c√†i ƒë·∫∑t OpenVPN: https://openvpn.net/community-downloads/")
                return False
            
            logger.info(f"ƒêang k·∫øt n·ªëi VPN: {config_path}")
            
            # T·∫°o l·ªánh k·∫øt n·ªëi
            cmd = [openvpn_cmd, '--config', config_path]
            
            if require_admin:
                logger.warning("‚ö†Ô∏è  C·∫ßn quy·ªÅn Administrator ƒë·ªÉ k·∫øt n·ªëi VPN")
            
            # Ch·∫°y OpenVPN process ·∫©n (kh√¥ng hi·ªán console)
            # Tr√™n Windows: CREATE_NO_WINDOW ƒë·ªÉ ch·∫°y ng·∫ßm
            if os.name == 'nt':  # Windows
                # CREATE_NO_WINDOW = 0x08000000 - Ch·∫°y process kh√¥ng hi·ªán c·ª≠a s·ªï
                CREATE_NO_WINDOW = 0x08000000
                self.current_process = subprocess.Popen(
                    cmd,
                    creationflags=subprocess.CREATE_NEW_PROCESS_GROUP | CREATE_NO_WINDOW,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            else:  # Linux/Mac
                self.current_process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    start_new_session=True
                )
            
            # L∆∞u PID ƒë·ªÉ qu·∫£n l√Ω sau
            with open(self.pid_file, 'w') as f:
                f.write(str(self.current_process.pid))
            
            logger.info(f"ƒê√£ kh·ªüi ƒë·ªông OpenVPN process (PID: {self.current_process.pid})")
            
            # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ki·ªÉm tra k·∫øt n·ªëi
            logger.info("ƒêang ch·ªù OpenVPN kh·ªüi ƒë·ªông...")
            for i in range(10):  # Check trong 10 gi√¢y
                time.sleep(1)
                if self.is_connected():
                    logger.info("‚úÖ ƒê√£ k·∫øt n·ªëi VPN th√†nh c√¥ng!")
                    return True
                # Ki·ªÉm tra process c√≤n ch·∫°y kh√¥ng
                if self.current_process.poll() is not None:
                    logger.error("OpenVPN process ƒë√£ d·ª´ng. Ki·ªÉm tra quy·ªÅn admin ho·∫∑c config file.")
                    return False
            
            logger.warning("‚ö†Ô∏è  OpenVPN ƒëang ch·∫°y nh∆∞ng ch∆∞a k·∫øt n·ªëi xong.")
            logger.info("üîç Ch·∫°y 'vpn_tool.py status' sau √≠t ph√∫t ƒë·ªÉ ki·ªÉm tra.")
            return True
                
        except Exception as e:
            logger.error(f"L·ªói khi k·∫øt n·ªëi: {e}")
            return False
    
    def disconnect(self) -> bool:
        """
        Ng·∫Øt k·∫øt n·ªëi VPN hi·ªán t·∫°i.
        
        Returns:
            True n·∫øu th√†nh c√¥ng
        """
        try:
            # ƒê·ªçc PID t·ª´ file n·∫øu c√≥
            if os.path.exists(self.pid_file):
                try:
                    with open(self.pid_file, 'r') as f:
                        pid = int(f.read().strip())
                    
                    import psutil
                    if psutil.pid_exists(pid):
                        proc = psutil.Process(pid)
                        proc.terminate()
                        proc.wait(timeout=5)
                        logger.info(f"‚úÖ ƒê√£ ng·∫Øt OpenVPN process (PID: {pid})")
                    
                    os.remove(self.pid_file)
                except Exception as e:
                    logger.warning(f"Kh√¥ng th·ªÉ kill process t·ª´ PID file: {e}")
            
            # Fallback: kill t·∫•t c·∫£ OpenVPN processes
            killed = self._kill_openvpn_processes()
            if killed:
                logger.info(f"‚úÖ ƒê√£ ng·∫Øt {killed} k·∫øt n·ªëi VPN")
            else:
                logger.info("‚ÑπÔ∏è  Kh√¥ng c√≥ k·∫øt n·ªëi VPN n√†o ƒëang ho·∫°t ƒë·ªông")
            
            self.current_process = None
            return True
                    
        except Exception as e:
            logger.error(f"L·ªói khi ng·∫Øt k·∫øt n·ªëi: {e}")
            return False
    
    def is_connected(self) -> bool:
        """
        Ki·ªÉm tra VPN c√≥ ƒëang k·∫øt n·ªëi kh√¥ng.
        
        Returns:
            True n·∫øu ƒëang k·∫øt n·ªëi
        """
        # Ki·ªÉm tra process c√≤n ch·∫°y
        if self.current_process and self.current_process.poll() is None:
            return True
        
        # Ki·ªÉm tra c√≥ OpenVPN process n√†o ƒëang ch·∫°y
        import psutil
        for proc in psutil.process_iter(['name']):
            try:
                if 'openvpn' in proc.info['name'].lower():
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        
        return False
    
    def get_status(self) -> Dict:
        """
        L·∫•y tr·∫°ng th√°i k·∫øt n·ªëi VPN chi ti·∫øt.
        
        Returns:
            Dict ch·ª©a th√¥ng tin status
        """
        connected = self.is_connected()
        
        status = {
            'connected': connected,
            'process_running': self.current_process is not None,
            'ip_address': self._get_public_ip() if connected else None
        }
        
        return status
    
    def _find_openvpn(self) -> Optional[str]:
        """
        T√¨m OpenVPN executable.
        
        Returns:
            ƒê∆∞·ªùng d·∫´n ƒë·∫øn openvpn.exe ho·∫∑c None
        """
        # C√°c v·ªã tr√≠ th∆∞·ªùng g·∫∑p tr√™n Windows
        possible_paths = [
            r"C:\Program Files\OpenVPN\bin\openvpn.exe",
            r"C:\Program Files (x86)\OpenVPN\bin\openvpn.exe",
            "openvpn"  # Trong PATH
        ]
        
        for path in possible_paths:
            try:
                result = subprocess.run(
                    [path, '--version'],
                    capture_output=True,
                    timeout=2
                )
                if result.returncode == 0:
                    return path
            except:
                continue
        
        return None
    
    def _kill_openvpn_processes(self) -> int:
        """
        Kill t·∫•t c·∫£ OpenVPN processes.
        
        Returns:
            S·ªë process ƒë√£ kill
        """
        import psutil
        killed = 0
        
        for proc in psutil.process_iter(['name', 'pid']):
            try:
                if 'openvpn' in proc.info['name'].lower():
                    proc.terminate()
                    killed += 1
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        
        return killed
    
    def _get_public_ip(self) -> Optional[str]:
        """
        L·∫•y ƒë·ªãa ch·ªâ IP c√¥ng khai hi·ªán t·∫°i.
        
        Returns:
            IP address ho·∫∑c None
        """
        try:
            response = requests.get('https://api.ipify.org?format=json', timeout=5, proxies={'http': None, 'https': None})
            return response.json().get('ip')
        except:
            return None
